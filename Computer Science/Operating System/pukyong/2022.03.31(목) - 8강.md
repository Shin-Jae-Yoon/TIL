프로세스 종료

-   프로세스 자신이 종료하는 경우 : exit() system call을 통해서 프로세스를 종료. 이 시점에서 프로세스는 부모 프로세스에 상태 값을 전달하고 종료된다. 부모 프로세스는 wait() 함수를 통해서 자식 프로세스로부터 해당 상태 값을 반환받는다. 프로세스가 종료되면 운영체제로부터 받은 자원을 다시 돌려준다.

-   부모 프로세스가 자식 프로세스를 종료하는 경우 : abort() system call을 통해서 자식 프로세스 실행을 중지시킬 수 있다.

    -   자식 프로세스가 할당받은 자원의 범위를 넘어가는 경우(다른 프로세스가
        사용하는 메모리를 참조하는 경우이다.
    -   자식 프로세스가 더는 수행할 일이 없을 때
    -   부모 프로세스가 종료되고 나면 자식 프로세스가 종료되는 것이 맞다.
        카카오톡의 경우, 카카오톡을 종료하면 채팅방이 아직 자신의 일을 끝마친 것이
        아니라서 exit()로 종료하는 것이 아니라 부모 프로세스가 abort()로 종료시킨다.

-   연쇄식 종료(cascading termination) : 부모, 자식, 자식으로부터 비롯된 자식 모두 연쇄적으로 종료되는 경우이다. 이 종료는 운영체제에 의해 시작이 된다.

-   wait() system call은 부모 프로세스가 자식 프로세스가 exit() system call을 호출할 때까지 기다리는 것이다. 부모가 자식에게 상태를 주소값으로 넘겨줬다. 자식이 이 주소값을 받아서 기록하게 되면 부모 프로세스에 정보를 돌려줄 수 있는 것이다. 그냥 wait() 함수로 값을 복사해서 전달하면 자식 프로세스에서 수정해도 부모 프로세스에는 상태 값에는 영향을 미치지 않는다. 그래서 주소를 넘기는 것이다.
-   고아 프로세스 : 부모 프로세스가 자식 프로세스를 생성하고 부모가 자기 할 일만 하고 그냥 종료되어 사라지고 자식 프로세스가 고아가 된 상태이다.
-   좀비 프로세스 : 부모 프로세스가 기다리지 않고 끝내는 상태이다. 고아 프로세스와의 차이는 뭘까? 부모 프로세스가 fork() 해서 자식 프로세스를 생성하고 작업을 하다가 wait()를 아직 하지 않았는데 자식 프로세스의 일이 이미 끝나버린 상태이다. 부모 프로세스 입장에서는 자식 프로세스가 살아있는 것은 맞는데 살아있는 상태가 아닌 것처럼 보인다.

멀티프로세스 구조 – 크롬

-   탭 하나를 열 때마다 탭 들에 해당하는 프로세스가 모두 존재한다.

프로세스 간 통신

-   프로세스 간에는 통신이 되도록 설계가 되어있다. 독립적이거나 상호협력 할 수 있다. 상호협력한다는 것은 통신할 수 있는 환경을 제공하는 것이다. 이렇게 프로세스 협력을 허용하는 환경을 제공하는 데는 몇 가지 이유가 있다.

-   정보 공유 : 정보를 병행적으로 접근할 수 있는 환경을 제공
-   계산 가속화 : 프로세스 간 병렬 연산을 통해서 계산 속도를 빠르게
-   모듈성 : 시스템 기능을 별도의 프로세스, 스레드들로 나누어 모듈식 형태로 시스템을 구성하기를 원할 수도 있다.

IPC ( Interprocess communication ) 프로세스 간 통신 기법

-   공유 메모리(shared memory) : 프로세스 사이에 매개체인 메모리를 거쳐서 통신한다.

-   메시지 전달(message passing) : 프로세스 간에 메시지를 주고받으면서 통신한다.

협력 프로세스 (Cooperating Processes)

-   독립적인 프로세스는 하나의 프로세스가 다른 프로세스의 실행을 방해해서는 안 된다.
-   협력적인 프로세스는 다른 프로세스의 실행에 영향을 끼칠 수 있다.
-   독립적인 프로세스를 만들고 프로세스 간 통신을 통해 협업할 수 있도록 만든다.

생산자-소비자 문제

-   협력하는 프로세스의 일반적인 패러다임이다. 생산자 프로세스는 정보를 생성하고 소비자 프로세스는 정보를 소비한다. 생산자-소비자 문제의 하나의 해결책은 공유 메모리를 사용하는 것이다. 생산자가 정보를 채워 넣고 소비자가 소모할 수 있는 항목들의 버퍼가 반드시 사용 가능 해야 한다. 이 버퍼는 생산자와 소비자가 공유하는 메모리 영역에 존재하게 된다.
-   생산자와 소비자가 반드시 동기화되어야 생산되지도 않는 항목들을 소비자가 소비하려고 시도하지 않을 것이다.
-   두 가지 유형의 버퍼가 사용된다.
    -   무한 버퍼(unbounded-buffer) : 소비자 신경 쓰지 않고 계속 생산 가능
    -   유한 버퍼(bounded-buffer) : 독립적인 프로세스 간 공유 메모리 이용한 통신

IPC – 공유 메모리

-   프로세스 간 공유할 수 있는 공유 메모리를 만든다.
-   이 통신은 사용자 프로세스들이 제어하는 것이고 운영체제는 관여하지 않는다.
-   위에 생산자-소비자 문제의 유한 버퍼 방식은 운영체제가 관여하는 방식이다. 상대 프로세스를 wake up 하거나 sleep 하게 notify 하는 것이니까.
-   공유 메모리는 writing 하는 과정에서 항상 동기화 문제를 겪는다. 그 어떤 프로세스도 동시에 작성할 수 없는 곳을 크리티컬 섹션이라고 한다.

IPC – 메시지 전달

-   메시지 전달 기법은 프로세스 간에 공유하는 변수를 사용해야 하고 이런 것은 없다.
-   단순하게 메시지를 send(), receive() 하면 된다.
-   통신하려면 통신 연결(communication link)이 설정되어야 한다.
-   구현에 관한 문제

    -   어떻게 통신 연결을 설정할 것인가?
    -   어떻게 이 연결 들을 두 개 이상의 프로세스를 연관 지을 것이냐?
    -   얼마나 많은 링크를 만들어야 하는가?
    -   링크의 용량은 어느 정도로 하는가?
    -   링크의 방향은 일방향이냐 양방향이냐?

-   통신 연결의 구현 (물리적) : 공유 메모리, 하드웨어 버스, 네트워크
-   통신 연결의 구현 (논리적) : 직접적/간접적, 동기식/비동기식, 자동/명시적 버퍼링
-   예를 들어, 이메일의 경우는 간접적 통신이다. 상대방 주소에 보내는 것이 아니라 메일 시스템에 보내는 것이고 받는 사람도 메일 시스템에 접속해서 보는 것이다.
-   문자 메시지를 보내면 상대방에서 바로 볼 수 있는 동기식, 그러나, 이메일은 메일 시스템에 접속해야 볼 수 있으니까 비동기식

직접 통신

-   send(P, message) : P 프로세스에 메시지를 보낸다.
-   receive(Q, message) : Q 프로세스로부터 메시지를 받는다.
-   통신 설정은 자동으로 설정된다.
-   두 개의 프로세스(한 쌍의 프로세스)는 하나의 링크만 존재한다.
-   보통 양방향으로 보내는 것 하나 받는 것 하나이다.
-   프로세스가 여러 개라면, 확장성에서 굉장히 불리하다.

간접 통신

-   메일 박스를 만들어서 통신한다.
    -   통신하고자 하는 프로세스가 메일 박스를 만든다.
    -   프로세스는 메일 박스를 통해서만 통신할 수 있다.
    -   프로세스 간 메일 박스를 통해서 링크가 연관된다.
-   포트를 통해서 메일 박스에 접속한다.
-   통신하다가 필요없어지면 메일 박스를 파괴한다.
-   상대방을 지칭하지 않고 메일 박스를 지칭한다.
-   send(A, message) : A 메일 박스에 메시지를 보낸다.
-   receive(A, message) : A 메일 박스로부터 메시지를 받는다.

-   메일 박스는 3개 이상의 프로세스가 공유하는 통신을 가능하게 한다.

-   만약, P1이 보내고 P2와 P3가 받는 상황에 누가 메시지를 받을까?
-   해결방법

1. 하나의 링크는 최대 두 개의 프로세스와 연관되도록 허용
2. 시간을 정해서 P2가 읽는 시간, P3가 읽는 시간 정한다. 그러면 P1이 P2에 보내려면 그 시간에 보내고 P3에 보내려면 그 시간에 보낸다. 이 말을 어렵게 하면, 한순간에 최대로 하나의 프로세스가 receive() 연산을 실행하도록 허용한다.
3. 시스템이 누가 받을지 정해줄 수 있음

동기화

-   메시지 전달 기법 통신에서 봉쇄형(blocking), 비봉쇄형(nonblocking) 방식이 있다. 이때, 봉쇄형은 동기식, 비봉쇄형은 비동기식이라고 알려져 있다.
-   봉쇄형 보내기 : 송신하는 프로세스가 수신하는 프로세스가 수신할 때까지 아무것도 안하고 기다린다.
-   봉쇄형 받기 : 수신하는 프로세스가 메시지를 수신할 때까지 아무것도 안 한다.
-   비봉쇄형 보내기 : 송신하는 프로세스가 메시지를 송신하고 자기 할 일 한다.
-   비봉쇄형 받기 : 수신하는 프로세스가 유효한 메시지 혹은 널을 받는다.
-   만약, 송신자와 수신자가 모두 봉쇄형 방식을 사용하면, 랑데부 지점이 있어야 한다.

버퍼링

-   버퍼에 메시지 큐를 링크해서 넣는다. Producer과 Consumer 사이에 buffer를 넣음.
-   통신이 직접적이든 간접적이든 간에 통신하는 프로세스들에 의해 교환되는 메시지는 임시 큐에 들어있다. 기본적으로 이런 큐를 구현하는 방식은 세 가지가 있다.

1. 무용량 : 큐의 최대 길이가 0이다. 즉, 큐의 수용 공간이 0이라서 (꽉 차서) 메시지가 보관되지 않는다. 따라서 송신자는 수신자가 메시지를 수신하기 전까지 봉쇄되어야 한다. 랑데부 방식이다.
2. 유한 용량 : 큐는 n의 길이를 가진다. 큐가 빈 상태면 수신자는 송신자가 송신하기 전까지 봉쇄되어야 하고 큐가 꽉 찬 상태면 송신자는 수신자가 수신하기 전까지 봉쇄되어야 한다.
3. 무한 용량 : 송신자는 기다릴 필요 없이 계속 송신이 가능하다. 송신자는 절대 봉쇄되지 않는다.

IPC 시스템을 POSIX로 구현한 예제

-   프로세스가 공유 메모리에 세그먼트 일부를 생성할 수 있다.

    name은 공유 메모리의 이름, O_CREAT는 해당 name을 가진 공유 메모리가 있으면
    만들지 말고 없으면 만들어라, O_RDWR는 읽기, 쓰기가 가능하게 생성, 0666은
    공유 메모리 객체의 파일 접근권을 허가하는 것이다. 최종적으로 파일 디스크립터가
    반환되어 저장된다.

    ftruncate는 파일 디스크립터가 가리키는 곳을 잘라라. 해당 객체의 크기가
    4096 bytes 이다.

    공유 메모리의 공간에 저걸 작성해라. 아래는 생산자 관점 POSIX 작성이다.

-   헤더 파일
    #include <fctnl.h> : 파일 컨트롤러
    #include <sys/shm.h> : 시스템의 공유 메모리
    #include <sys/stat.h> : 파일의 상태 및 정보를 얻는 것
-   파일 디스크립터가 가리키는 공유 메모리 객체의 크기 = 4096 bytes
-   공유 메모리의 이름 = OS
-   공유 메모리에 작성할 문자열 = Hello World!
-   공유 메모리 객체를 가리키는 파일 디스크립터를 저장할 변수 생성
-   공유 메모리를 가리키기 위한 포인터를 생성
-   메모리 map을 이용해서 공유 메모리 객체를 실제로 맵핑 하는 것이다. 공유 메모리와 메모리를 가리킬 수 있도록 주소값을 가져와서 포인터와 맵핑한 것이다.
-   sprintf를 통해 해당 메모리에 message 0을 저장한다.
-   문자열의 길이만큼 포인터를 뒤로 이동시켜서 해당 부분에 message 0을 저장한다.
-   실제로 메모리에 할당되는 값은 mmap(~) 이 부분이다.

-   생산자와 다른 점은 생산자는 O_CREATE 였는데, 소비자는 O_RDONLY이다.
-   메모리에 실제로 맵핑을 하고.
-   해당하는 곳에 있는 데이터를 문자열의 첫 주소로서 가져오고 printf로 출력한다.
-   shm_unlink를 통해 연결을 끊겠다.

IPC 시스템을 Mach(매킨토시)로 구현한 예제

-   macOS 계열의 방식인데, 포트를 이용한다. 포트는 메일 박스 역할을 하고 커널에서 만들고 notify를 통해 어떤 메시지가 왔다고 알려준다. system calls도 메시지로 전달된다. 그냥 이거는 원래는 메일 박스인데 매킨토시에서는 포트라고 기억하자.

IPC 시스템을 Windows로 구현한 예제

-   메시지 전달(Message-passing) 방식 위주이다. 고급 로컬 프로시저 호출 설비(advanced local procedure call facility, ALPC) 혹은 고급 로컬 프로시저 호출(advanced local procedure call, LPC)
-   LPC는 쉽게 말해 로컬 프로시저 콜은 한 시스템 내에서 다른 프로시저에 데이터를 전달하거나 할 때는 메시지를 전달함으로써 통신할 수 있다는 것이다.
-   동일 시스템에 있는 프로세스 간 통신 기법이다.
-   포트를 사용한다. (메시지 박스처럼) 이를 이용해서 통신 채널을 유지한다.

-   클라이언트가 연결 포트(connection port) 객체를 하나 생성한다. 그러면 클라이언트가 연결 요청을 보낸다. 서버가 두 개의 개인의(private) 통신 포트(communication port)를 열고 둘 중 하나를 클라이언트에 전달한다. 클라이언트와 서버는 해당 포트를 메시지를 송신, 수신하려고 사용한다. 256 bytes가 넘어가면 메시지를 송수신 한다.

소켓

-   통신을 위한 엔드포인트다. IP와 포트를 통해서 통신한다.
