# 2022.03.25(금) - 운영체제 수업

<br>

## Process

<br>

<strong>프로세스 개념</strong>

-   프로세스는 어떤 작업의 절차이다. 프로세서는 프로세스와는 다른 것인데 프로세서는 CPU이고 프로세스는 소프트웨어적인 측면에서 작업을 수행하는 가상의 기기이다.
-   운영체제에서 실제로 동작하는 프로그램이 프로세스이다.
-   초창기 컴퓨터는 하나의 작업(작업, batch system)을 수행하는 프로그램이었고 다음에는 시분할 시스템으로 여러 사람의 프로그램을 동시에 실행할 수 있는 프로그램이 되었다.
-   책에서는 작업과 프로세스를 똑같이 취급한다.

-   프로세스는 실행되고 있는 프로그램이다. 프로그램은 수동적인 개체(passive entity), 프로세스는 능동적인 개체(active entity)이다.

-   우리가 프로그램은 만들면 크게 text section / data section으로 나뉜다. 소스 코드에서 실행 코드 부분을 text section, 프로그램이 실행되는 동안 필요한 데이터(예를 들어, 전역 변수)를 data section이라고 한다.

-   사용자가 프로그램을 더블클릭하면, 메모리에 공간을 할당받으면서 프로세스가 되는데 이런 식으로 메모리에 공간을 할당받는다. 힙 섹션은 프로그램 실행 중에 동적으로 할당되는 메모리, 스택 섹션은 함수가 호출될 때마다 해당 함수에서 선언한 변수가 저장되는 공간이다. 함수가 호출될 때마다 위에서 아래로 자라난다. 메모리 주소 0번이 하위, max가 상위인데 스택은 상위 주소에서 하위 주소로 자란다.

<strong>프로세스 상태 – CPU가 놀지 않게 하려고! 5가지 상태!</strong>

-   새로운(new) : 프로세스가 생성 중이다.
-   실행(running) : 명령어들이 실행되고 있다.
-   대기(waiting) : 프로세스가 어떤 이벤트가 일어나기를 기다린다. 이때 이벤트는 입출력 완료 또는 신호의 수신 같은 것이다.
-   준비(ready) : 프로세스가 처리기에 할당되기를 기다린다.
-   종료(terminated) : 프로세스의 실행이 종료되었다.

<strong>프로세스 제어 블록(Process Control Block, PCB)</strong>

-   프로세스 5가지 상태 정보가 기록되는 곳이 PCB이다. PCB는 RAM에 저장된다.

-   프로세스 상태 : 위의 프로세스 상태 정보가 저장
-   프로세스 번호 : 프로세스의 번호 저장
-   프로그램 카운터 : 앞으로 실행할 명령어의 주소를 가리킴
-   CPU 레지스터들 : 나중에 프로세스가 다시 스케줄 될 때 올바르게 실행되도록 하려고 인터럽트 발생 시 저장되어야 함
-   CPU 스케줄링 정보

-   프로세스는 어떤 프로세스에서 다른 프로세스로 “전환”이 필요하다. 이걸 문맥 교환, Context Switching이라고 한다. 프로세스 0에서 진행 중인 명령어를 잠시 멈추고 프로세스 1에서 진행 중인 명령어를 실행한다. 문맥교환!
-   프로그램을 조금씩 조금씩 실행하는 시분할 시스템을 사용 중이다.

<strong>스레드(Threads)</strong>

-   스레드는 하나의 프로세스에서 실행할 수 있는 여러 개의 실행이다. 프로세스에서 여러 개의 스레드를 가질 수 있다.

리눅스에서 프로세스의 표현

-   linux/sched.h 헤더 파일에 아래의 내용이 있다. PCB는 더블 링크 형태로 구성되어있다. 교재 124쪽 참고
    프로세스 스케줄링
-   프로세스 스케줄러가 CPU에서 다음에 어떤 프로세스를 실행시킬지 선택한다.
-   PCB가 리스트 형태로 구성되어있는데, 이것을 저장하고 있는 것은 큐이다.
-   프로세스를 관리하기 위한 큐가 여러 개가 있다. 작업 큐(job queue)는 현재 실행되고 있는 프로세스의 모든 정보를 담고 있다. 준비 큐(ready queue)는 준비(ready) 상태에 있는 프로세스를 저장하고 있는 큐이다. 장치 큐(Device queues)는 입출력 장치 사용을 대기(wait)하고 있는 큐이다. 프로세스는 여러 개의 큐 사이를 왔다 갔다 한다.

-   장치 큐가 복수인 이유 : 컴퓨터의 장치마다 큐가 있기 때문이다. 어떤 프로세스는 네트워크 카드를 사용하려고 waiting 할 수도, 어떤 프로세스는 HDD에 writing 하려고 waiting 할 수도 있다. 각각의 프로세스는 해당하는 장치와 연결된 큐에 저장되어 있다.

타임 슬라이스는 프로세스가 최대 실행될 수 있는 시간. 125쪽 참고
스케줄러 (126쪽에 짧게 있음)

-   단기 스케줄러(Short-term scheduler / CPU scheduler) : ready queue에서 준비하고 있는 프로세스들을 꺼내서 CPU를 통해 실행하기 위하여 CPU에 자원을 할당하는 것이다. 대부분 시스템에서 스케줄러는 단기 스케줄러를 의미한다. 굉장히 자주 동작한다. 밀리초 단위로 스케줄링한다. 굉장히 빨라야 한다.

-   장기 스케줄러(Long-term scheduler / job scheduler) : 어떤 프로세스를 ready queue에 담을까 하는 것이다. 멀티프로그래밍에 관련된 스케줄러이다.

-   CPU가 느려질 때는 I/O 작업, 조건문 같은 분기문을 만났을 때다. 최근의 CPU는 A, B 둘다 조건문을 일단 실행하고 조건에 맞는 것은 가져가고 나머지는 버리는 식으로 한다.

-   프로세스는 두 종류가 있다.
-   I/O-bound 프로세스 : 입출력 작업이 많은 프로세스
-   CPU-bound 프로세스 : CPU 연산 작업이 많은 프로세스

-   중기 스케줄러(Medium-term scheduler) : 일부 운영체제는 스와핑으로 알려진 중간 형태의 스케줄링을 가진다. 메모리에서 실행되고 있는 프로세스를 빼고 다른 프로세스를 중간에 넣어버리는 것이다.

모바일 시스템의 멀티태스킹

-   IOS의 초기 버전의 경우 하나의 프로세스만 실행하고 다른 프로세스는 멈춘 상태이다. 한 번에 하나씩의 프로세스만 실행할 수 있는 상태이다. 전경(foreground)와 백그라운드(background) 프로세스가 있는데 전경에 있는 응용은 현재 화면에 보이면서 실행 중인 응용이고 백그라운드 응용은 메모리에 남아 있지만, 화면에는 보이지 않는 응용이다. 안드로이드는 시작부터 멀티태스킹을 지원하여서 상대적으로 안드로이드가 ios보다 메모리를 많이 사용한다.

문맥 교환(Context Switch)

-   문맥 교환의 정의는 현재 실행 중인 프로세스의 문맥(명령어)이나 상태 정보를 바꾼다는 것이다. PCB에 있는 정보를 문맥(context)라고 한다.
-   준비 큐(ready queue)에 P1, P2, P3가 있다고 하자. 여기서 하나씩 꺼내서 CPU에서 실행하는데 만약 P1을 실행 중이라고 하자. P1을 실행할 수 있는 최대 시간이 되었거나 다른 이유로 CPU에서 꺼내게 된다. 그리고 준비 큐에서 P2를 꺼내서 다시 CPU에 넣어서 실행한다. 그러면 P1에서 실행되고 있던 CPU 상태들을 어딘가에 기록해야겠지? 나중에 P1 차례가 와서 자원을 할당받고 실행할 때 전에 실행되었던 다양한 상태 정보를 가져와서 실행할 것이니까.
-   문맥 교환은 오버헤드이다. 한마디로 불필요한 작업이고 낭비라는 것이다. 그래서 운영체제나 PCB가 복잡할수록 문맥 교환에 오랜 시간이 걸린다.
-   그래서 PCB에 있는 내용을 단순하게 만들면 만들수록 문맥 교환이 빨리 된다.
-   어떤 시스템은 CPU의 정말 다양한 레지스터를 본다. CPU의 레지스터에 현재 실행 중인 프로세스의 정보를 레지스터에 저장하고 새로운 프로세스의 정보를 레지스터에 올리고 바로 CPU에 올린다. 문맥 교환의 오버헤드를 줄이기 위한 노력!

프로세스 관리

-   프로세스를 생성하고 종료하고 기타 등등의 일을 하는 것이다.

프로세스 생성

-   프로세스는 내부적으로 트리 구조이다.

-   부모 프로세스는 자식 프로세스를 생성할 수 있다. 자식 프로세스는 또 다른 자식 프로세스를 생성할 수 있다. fork() 함수를 이용해서
-   프로세스는 pid라는 process identifier로 구분된다.
-   프로세스 자원 공유의 3가지 옵션
    1.  부모와 자식 프로세스 간에 모든 자원을 공유한다.
    2.  자식 프로세스는 부모 프로세스의 자원을 일부 공유한다.
    3.  부모는 자식 프로세스에 자원을 공유하지 않는다.
-   프로세스 실행 옵션

    1.  부모와 자식 프로세스는 동시에 실행한다.
    2.  부모 프로세스가 자식 프로세스의 종료까지 기다린다.

-   init 프로세스는 pid가 1이다. init 프로세스는 운영체제가 부팅되고 나면 init 프로세스를 통해서 자식 프로세스를 생성한다.

-   주소 공간 : 부모 프로세스가 자식 프로세스를 생성하고, 자식 프로세스가 하는 일은 부모 프로세스와 같을 수도 있고, 새로운 일을 할 수도 있다.
-   fork() system call은 새로운 프로세스를 만드는 것
-   exec() system call은 fork()를 통해서 프로세스 메모리 공간을 새로운 프로그램에 담는다. exec()가 없으면 자식 프로세스는 부모 프로세스와 같은 작업을 수행한다.

-   pid가 0으로 자식 프로세스라면, /bin/ls에 ls 명령어를 전달해서 실행해라!
